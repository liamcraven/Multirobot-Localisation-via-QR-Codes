import numpy as np

# Array mapping QR code version to the total number of codewords (including error correction)
# Padded for intuitive indexing
QR_VERSION_CODEWORDS = [
    -1, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346,
    404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,
    1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,
    2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706
]

FORMAT_INFO = { 
    'L': {
        0: '111011111000100',
        1: '111001011110011',
        2: '111110110101010',
        3: '111100010011101',
        4: '110011000101111',
        5: '110001100011000',
        6: '110110001000001',
        7: '110100101110110',
    },
    'M': {
        0: '101010000010010',
        1: '101000100100101',
        2: '101111001111100',
        3: '101101101001011',
        4: '100010111111001',
        5: '100000011001110',
        6: '100111110010111',
        7: '100101010100000',
    },
    'Q': {
        0: '011010101011111',
        1: '011000001101000',
        2: '011111100110001',
        3: '011101000000110',
        4: '010010010110100',
        5: '010000110000011',
        6: '010111011011010',
        7: '010101111101101',
    },
    'H': {
        0: '001011010001001',
        1: '001001110111110',
        2: '001110011100111',
        3: '001100111010000',
        4: '000011101100010',
        5: '000001001010101',
        6: '000110100001100',
        7: '000100000111011',
    },
}

VERSION_INFO = [None, None, None, None, None, None, None,
    '000111110010010100', '001000010110111100', '001001101010011001',
    '001010010011010011', '001011101111110110', '001100011101100010',
    '001101100001000111', '001110011000001101', '001111100100101000',
    '010000101101111000', '010001010001011101', '010010101000010111',
    '010011010100110010', '010100100110100110', '010101011010000011',
    '010110100011001001', '010111011111101100', '011000111011000100',
    '011001000111100001', '011010111110101011', '011011000010001110',
    '011100110000011010', '011101001100111111', '011110110101110101',
    '011111001001010000', '100000100111010101', '100001011011110000',
    '100010100010111010', '100011011110011111', '100100101100001011',
    '100101010000101110', '100110101001100100', '100111010101000001',
    '101000110001101001'
]

MASK_PATTERNS = [
        lambda i, j: (i + j) % 2 == 0,
        lambda i, j: i % 2 == 0,
        lambda i, j: j % 3 == 0,
        lambda i, j: (i + j) % 3 == 0,
        lambda i, j: (i // 2 + j // 3) % 2 == 0,
        lambda i, j: (i * j) % 2 + (i * j) % 3 == 0,
        lambda i, j: ((i * j) % 2 + (i * j) % 3) % 2 == 0,
        lambda i, j: ((i + j) % 2 + (i * j) % 3) % 2 == 0
]

# Enum for error correction levels
class ErrorCorrectionLevel: 
    ordinal: int # 0-3
    format_bits: int # 2 bits

    def __init__(self, ordinal: int, format_bits: int, string: str, recovery_capacity: float):
        self.ordinal = ordinal
        self.format_bits = format_bits
        self.string = string
        self.recovery_capacity = recovery_capacity
        
    def get_ord(self):
        return self.ordinal
    
    def get_format_bits(self):
        return self.format_bits
    
    def get_str(self):
        return self.string
    
    def get_recovery_capacity(self):
        return self.recovery_capacity

EC_LOW = ErrorCorrectionLevel(0, 0b01, "L", 0.07) # 7% of codewords can be restored
EC_MEDIUM = ErrorCorrectionLevel(1, 0b00, "M", 0.15) # 15% of codewords can be restored
EC_QUARTILE = ErrorCorrectionLevel(2, 0b11, "Q", 0.25) # 25% of codewords can be restored
EC_HIGH = ErrorCorrectionLevel(3, 0b10, "H", 0.3) # 30% of codewords can be restored

EC_LEVELS = [EC_HIGH, EC_MEDIUM, EC_LOW]
    
class BlockFormat:
    """
    Class for block format information.
    """
    def __init__(self, total_codewords, total_data_codewords, total_error_codewords):
        self.total_codewords = total_codewords
        self.num_data_codewords = total_data_codewords
        self.num_error_codewords = total_error_codewords
        
    def get_total_codewords(self):
        return self.total_codewords
    
    def get_num_data_codewords(self):
        return self.num_data_codewords
    
    def get_num_error_codewords(self):
        return self.num_error_codewords
    
BLOCK_COUNTS = {
    1: 1,
    2: 1,
    3: 2,
    4: 4,
    5: 4,
    6: 4,
    7: 6,
    8: 6,
    9: 8,
    10: 8,
    11: 8,
    12: 9,
    13: 16,
    14: 16,
    15: 18,
    16: 17,
    17: 19,
    18: 21,
    19: 25,
    20: 25,
    21: 25,
    22: 34,
    23: 30,
    24: 32,
    25: 35,
    26: 37,
    27: 40,
    28: 42,
    29: 45,
    30: 48,
    31: 51,
    32: 54,
    33: 57,
    34: 60,
    35: 63,
    36: 66,
    37: 70,
    38: 74,
    39: 77,
    40: 81,
}

QR_VERSION_CAPACITY = {1: 196,
    2: 354,
    3: 562,
    4: 802,
    5: 1074,
    6: 1378,
    7: 1653,
    8: 2021,
    9: 2421,    
    10: 2853,   
    11: 3317,   
    12: 3813,   
    13: 4341,   
    14: 4876,   
    15: 5468,   
    16: 6092,   
    17: 6748,   
    18: 7436,   
    19: 8156,   
    20: 8908,   
    21: 9667,
    22: 10483,
    23: 11331,
    24: 12211,
    25: 13123,
    26: 14067,
    27: 15043,
    28: 16026,
    29: 17066,
    30: 18138,
    31: 19242,
    32: 20378,
    33: 21546,
    34: 22746,
    35: 23953,
    36: 25217,
    37: 26513,
    38: 27841,
    39: 29201,
    40: 30593,
}





"""
# Array for maximum data capacity (in bytes) for each QR code version and error correction level
QR_VERSION_CAPACITY = [
    [19, 16, 13, 9],
    [34, 28, 22, 16],
    [55, 44, 34, 26],
    [80, 64, 48, 36],
    [108, 86, 62, 46],
    [136, 108, 76, 60],
    [156, 124, 88, 66],
    [194, 154, 110, 86],
    [232, 182, 132, 100],
    [274, 216, 154, 122],
    [324, 254, 180, 140],
    [370, 290, 206, 158],
    [428, 334, 244, 180],
    [461, 365, 261, 197],
    [523, 415, 295, 223],
    [589, 453, 325, 253],
    [647, 507, 367, 283],
    [721, 563, 397, 313],
    [795, 627, 445, 341],
    [861, 669, 485, 385],
    [932, 714, 512, 406],
    [1006, 782, 568, 442],
    [1094, 860, 614, 464],
    [1174, 914, 664, 514],
    [1276, 1000, 718, 538],
    [1370, 1062, 754, 596],
    [1468, 1128, 808, 628],
    [1531, 1193, 871, 661],
    [1631, 1267, 911, 701],
    [1735, 1373, 985, 745],
    [1843, 1455, 1033, 793],
    [1955, 1541, 1115, 845],
    [2071, 1631, 1171, 901],
    [2191, 1725, 1231, 961],
    [2306, 1812, 1286, 986],
    [2434, 1914, 1354, 1054],
    [2566, 1992, 1426, 1096],
    [2702, 2102, 1502, 1142],
    [2812, 2216, 1582, 1222],
    [2956, 2334, 1666, 1276]
]
"""

FINDER_PATTERN = np.array([
                [1, 1, 1, 1, 1, 1, 1],
                [1, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 1, 1, 0, 1],
                [1, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1],
            ])

ALIGNMENT_PATTERN = np.array([
                [1, 1, 1, 1, 1],
                [1, 0, 0, 0, 1],
                [1, 0, 1, 0, 1],
                [1, 0, 0, 0, 1],
                [1, 1, 1, 1, 1],
            ])

ALIGNMENT_PATTERN_TABLE = [
    [],
    [],
    [6, 18],
    [6, 22],
    [6, 26],
    [6, 30],
    [6, 34],
    [6, 22, 38],
    [6, 24, 42],
    [6, 26, 46],
    [6, 28, 50],
    [6, 30, 54],
    [6, 32, 58],
    [6, 34, 62],
    [6, 26, 46, 66],
    [6, 26, 48, 70],
    [6, 26, 50, 74],
    [6, 30, 54, 78],
    [6, 30, 56, 82],
    [6, 30, 58, 86],
    [6, 34, 62, 90],
    [6, 28, 50, 72, 94],
    [6, 26, 50, 74, 98],
    [6, 30, 54, 78, 102],
    [6, 28, 54, 80, 106],
    [6, 32, 58, 84, 110],
    [6, 30, 58, 86, 114],
    [6, 34, 62, 90, 118],
    [6, 26, 50, 74, 98, 122],
    [6, 30, 54, 78, 102, 126],
    [6, 26, 52, 78, 104, 130],
    [6, 30, 56, 82, 108, 134],
    [6, 34, 60, 86, 112, 138],
    [6, 30, 58, 86, 114, 142],
    [6, 34, 62, 90, 118, 146],
    [6, 30, 54, 78, 102, 126, 150],
    [6, 24, 50, 76, 102, 128, 154],
    [6, 28, 54, 80, 106, 132, 158],
    [6, 32, 58, 84, 110, 136, 162],
    [6, 26, 54, 82, 110, 138, 166],
    [6, 30, 58, 86, 114, 142, 170]
]